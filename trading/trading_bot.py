"""
Automated Trading Module for Cryptocurrency Trading Bot

This module handles order execution, position management, and automated trading
based on signals generated by trading strategies.
"""

import os
import sys
import time
import logging
import pandas as pd
import numpy as np
from typing import Dict, List, Optional, Union, Tuple
from datetime import datetime, timedelta
import threading
import queue
import ccxt

# Import configuration and other modules
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
import config
from data.data_manager import create_data_manager
from data.market_streamer import create_market_data_streamer
from strategies.technical_indicators import create_technical_analyzer
from strategies.trading_strategies import create_strategy_manager

# Configure logging
logger = logging.getLogger('crypto_trading_bot.trading')

class OrderType:
    """Order type constants"""
    MARKET = "market"
    LIMIT = "limit"
    STOP_LOSS = "stop_loss"
    TAKE_PROFIT = "take_profit"
    STOP_LIMIT = "stop_limit"

class OrderSide:
    """Order side constants"""
    BUY = "buy"
    SELL = "sell"

class OrderStatus:
    """Order status constants"""
    OPEN = "open"
    CLOSED = "closed"
    CANCELED = "canceled"
    EXPIRED = "expired"
    REJECTED = "rejected"

class Order:
    """Class representing a trading order"""
    
    def __init__(self, symbol: str, order_type: str, side: str, amount: float, 
                price: Optional[float] = None, params: Dict = None):
        """
        Initialize order
        
        Args:
            symbol: Trading symbol
            order_type: Order type (market, limit, etc.)
            side: Order side (buy, sell)
            amount: Order amount
            price: Order price (required for limit orders)
            params: Additional parameters
        """
        self.symbol = symbol
        self.order_type = order_type
        self.side = side
        self.amount = amount
        self.price = price
        self.params = params or {}
        self.status = None
        self.id = None
        self.timestamp = None
        self.filled = 0.0
        self.remaining = amount
        self.cost = 0.0
        self.fee = 0.0
        self.trades = []
    
    def update(self, order_data: Dict):
        """
        Update order with data from exchange
        
        Args:
            order_data: Order data from exchange
        """
        self.id = order_data.get('id', self.id)
        self.status = order_data.get('status', self.status)
        self.timestamp = order_data.get('timestamp', self.timestamp)
        self.filled = order_data.get('filled', self.filled)
        self.remaining = order_data.get('remaining', self.remaining)
        self.cost = order_data.get('cost', self.cost)
        self.fee = order_data.get('fee', {}).get('cost', self.fee) if order_data.get('fee') else self.fee
        self.trades = order_data.get('trades', self.trades)
    
    def is_filled(self) -> bool:
        """Check if order is filled"""
        return self.status == OrderStatus.CLOSED and self.filled >= self.amount
    
    def to_dict(self) -> Dict:
        """Convert order to dictionary"""
        return {
            'id': self.id,
            'symbol': self.symbol,
            'type': self.order_type,
            'side': self.side,
            'amount': self.amount,
            'price': self.price,
            'status': self.status,
            'timestamp': self.timestamp,
            'filled': self.filled,
            'remaining': self.remaining,
            'cost': self.cost,
            'fee': self.fee
        }


class Position:
    """Class representing a trading position"""
    
    def __init__(self, symbol: str, side: str, amount: float, entry_price: float, 
                entry_time: datetime, stop_loss: Optional[float] = None, 
                take_profit: Optional[float] = None):
        """
        Initialize position
        
        Args:
            symbol: Trading symbol
            side: Position side (buy, sell)
            amount: Position amount
            entry_price: Entry price
            entry_time: Entry time
            stop_loss: Stop loss price
            take_profit: Take profit price
        """
        self.symbol = symbol
        self.side = side
        self.amount = amount
        self.entry_price = entry_price
        self.entry_time = entry_time
        self.stop_loss = stop_loss
        self.take_profit = take_profit
        self.exit_price = None
        self.exit_time = None
        self.pnl = 0.0
        self.pnl_percent = 0.0
        self.status = "open"
        self.entry_order_id = None
        self.exit_order_id = None
    
    def close(self, exit_price: float, exit_time: datetime, exit_order_id: str = None):
        """
        Close position
        
        Args:
            exit_price: Exit price
            exit_time: Exit time
            exit_order_id: Exit order ID
        """
        self.exit_price = exit_price
        self.exit_time = exit_time
        self.exit_order_id = exit_order_id
        self.status = "closed"
        
        # Calculate PnL
        if self.side == OrderSide.BUY:
            self.pnl = (exit_price - self.entry_price) * self.amount
            self.pnl_percent = (exit_price / self.entry_price - 1) * 100
        else:
            self.pnl = (self.entry_price - exit_price) * self.amount
            self.pnl_percent = (self.entry_price / exit_price - 1) * 100
    
    def update_stop_loss(self, price: float):
        """
        Update stop loss price
        
        Args:
            price: New stop loss price
        """
        self.stop_loss = price
    
    def update_take_profit(self, price: float):
        """
        Update take profit price
        
        Args:
            price: New take profit price
        """
        self.take_profit = price
    
    def should_close(self, current_price: float) -> bool:
        """
        Check if position should be closed based on stop loss or take profit
        
        Args:
            current_price: Current price
            
        Returns:
            True if position should be closed, False otherwise
        """
        if self.side == OrderSide.BUY:
            # Long position
            if self.stop_loss and current_price <= self.stop_loss:
                return True
            if self.take_profit and current_price >= self.take_profit:
                return True
        else:
            # Short position
            if self.stop_loss and current_price >= self.stop_loss:
                return True
            if self.take_profit and current_price <= self.take_profit:
                return True
        
        return False
    
    def to_dict(self) -> Dict:
        """Convert position to dictionary"""
        return {
            'symbol': self.symbol,
            'side': self.side,
            'amount': self.amount,
            'entry_price': self.entry_price,
            'entry_time': self.entry_time,
            'stop_loss': self.stop_loss,
            'take_profit': self.take_profit,
            'exit_price': self.exit_price,
            'exit_time': self.exit_time,
            'pnl': self.pnl,
            'pnl_percent': self.pnl_percent,
            'status': self.status,
            'entry_order_id': self.entry_order_id,
            'exit_order_id': self.exit_order_id
        }


class ExchangeInterface:
    """Interface for interacting with cryptocurrency exchanges"""
    
    def __init__(self, exchange_id: str):
        """
        Initialize exchange interface
        
        Args:
            exchange_id: Exchange identifier
        """
        self.exchange_id = exchange_id
        self.exchange_config = config.EXCHANGE_CONFIGS.get(exchange_id, {})
        self.exchange = self._initialize_exchange()
        logger.info(f"Initialized exchange interface for {exchange_id}")
    
    def _initialize_exchange(self):
        """Initialize exchange connection"""
        exchange_class = getattr(ccxt, self.exchange_id)
        
        # Prepare exchange parameters
        params = {
            'apiKey': self.exchange_config.get('api_key', ''),
            'secret': self.exchange_config.get('api_secret', ''),
            'enableRateLimit': True,
        }
        
        # Add additional parameters if provided
        if 'testnet' in self.exchange_config:
            params['testnet'] = self.exchange_config['testnet']
        
        if 'password' in self.exchange_config:
            params['password'] = self.exchange_config['password']
        
        # Create exchange instance
        exchange = exchange_class(params)
        
        # Load markets
        exchange.load_markets()
        
        return exchange
    
    def get_balance(self) -> Dict:
        """
        Get account balance
        
        Returns:
            Dictionary containing balance information
        """
        try:
            return self.exchange.fetch_balance()
        except Exception as e:
            logger.error(f"Error fetching balance: {e}")
            return {}
    
    def create_order(self, order: Order) -> Optional[Dict]:
        """
        Create order on exchange
        
        Args:
            order: Order to create
            
        Returns:
            Order data from exchange or None if error
        """
        try:
            # Check if API keys are configured
            if not self.exchange_config.get('api_key') or not self.exchange_config.get('api_secret'):
                logger.error("API keys not configured")
                return None
            
            # Create order on exchange
            order_data = self.exchange.create_order(
                symbol=order.symbol,
                type=order.order_type,
                side=order.side,
                amount=order.amount,
                price=order.price,
                params=order.params
            )
            
            # Update order with data from exchange
            order.update(order_data)
            
            logger.info(f"Created {order.side} {order.order_type} order for {order.amount} {order.symbol} at {order.price}")
            
            return order_data
            
        except Exception as e:
            logger.error(f"Error creating order: {e}")
            return None
    
    def cancel_order(self, order_id: str, symbol: str) -> bool:
        """
        Cancel order on exchange
        
        Args:
            order_id: Order ID
            symbol: Trading symbol
            
        Returns:
            True if order was canceled, False otherwise
        """
        try:
            self.exchange.cancel_order(order_id, symbol)
            logger.info(f"Canceled order {order_id} for {symbol}")
            return True
        except Exception as e:
            logger.error(f"Error canceling order: {e}")
            return False
    
    def get_order(self, order_id: str, symbol: str) -> Optional[Dict]:
        """
        Get order information from exchange
        
        Args:
            order_id: Order ID
            symbol: Trading symbol
            
        Returns:
            Order data from exchange or None if error
        """
        try:
            return self.exchange.fetch_order(order_id, symbol)
        except Exception as e:
            logger.error(f"Error fetching order: {e}")
            return None
    
    def get_open_orders(self, symbol: Optional[str] = None) -> List[Dict]:
        """
        Get open orders from exchange
        
        Args:
            symbol: Trading symbol (if None, get all open orders)
            
        Returns:
            List of open orders
        """
        try:
            return self.exchange.fetch_open_orders(symbol)
        except Exception as e:
            logger.error(f"Error fetching open orders: {e}")
            return []
    
    def get_ticker(self, symbol: str) -> Optional[Dict]:
        """
        Get ticker for symbol
        
        Args:
            symbol: Trading symbol
            
        Returns:
            Ticker data or None if error
        """
        try:
            return self.exchange.fetch_ticker(symbol)
        except Exception as e:
            logger.error(f"Error fetching ticker: {e}")
            return None


class TradingExecutor:
    """Class for executing trades based on signals"""
    
    def __init__(self, exchange_id: str, mode: str = 'signal'):
        """
        Initialize trading executor
        
        Args:
            exchange_id: Exchange identifier
            mode: Trading mode ('auto' or 'signal')
        """
        self.exchange_id = exchange_id
        self.mode = mode
        self.exchange = ExchangeInterface(exchange_id)
        self.data_manager = create_data_manager(exchange_id)
        self.market_streamer = create_market_data_streamer(exchange_id)
        self.strategy_manager = create_strategy_manager()
        
        # Initialize trading state
        self.active_positions = {}  # symbol -> Position
        self.order_history = []
        self.position_history = []
        
        # Initialize signal queue
        self.signal_queue = queue.Queue()
        
        # Initialize trading thread
        self.trading_thread = None
        self.is_running = False
        
        logger.info(f"Initialized trading executor for {exchange_id} in {mode} mode")
    
    def start(self):
        """Start trading executor"""
        if self.is_running:
            logger.warning("Trading executor is already running")
            return
        
        # Start market data streaming
        self.market_streamer.start()
        
        # Start trading thread
        self.is_running = True
        self.trading_thread = threading.Thread(target=self._trading_loop)
        self.trading_thread.daemon = True
        self.trading_thread.start()
        
        logger.info("Trading executor started")
    
    def stop(self):
        """Stop trading executor"""
        if not self.is_running:
            logger.warning("Trading executor is not running")
            return
        
        # Stop trading thread
        self.is_running = False
        if self.trading_thread:
            self.trading_thread.join(timeout=5.0)
        
        # Close connections
        self.data_manager.close()
        self.market_streamer.close()
        
        logger.info("Trading executor stopped")
    
    def _trading_loop(self):
        """Main trading loop"""
        while self.is_running:
            try:
                # Process signals from queue
                while not self.signal_queue.empty():
                    signal_data = self.signal_queue.get()
                    self._process_signal(signal_data)
                
                # Check active positions
                self._check_positions()
                
                # Sleep to avoid high CPU usage
                time.sleep(1.0)
                
            except Exception as e:
                logger.error(f"Error in trading loop: {e}")
                time.sleep(5.0)
    
    def _process_signal(self, signal_data: Dict):
        """
        Process trading signal
        
        Args:
            signal_data: Signal data
        """
        symbol = signal_data.get('symbol')
        signal = signal_data.get('signal')
        price = signal_data.get('price')
        timestamp = signal_data.get('timestamp')
        strategy = signal_data.get('strategy')
        
        if not all([symbol, signal, price, timestamp, strategy]):
            logger.error(f"Invalid signal data: {signal_data}")
            return
        
        logger.info(f"Processing signal: {symbol} {signal} at {price}")
        
        # Check if we have an active position for this symbol
        has_position = symbol in self.active_positions
        
        if signal > 0 and not has_position:
            # Buy signal and no active position
            if self.mode == 'auto':
                self._open_position(symbol, OrderSide.BUY, price, timestamp, strategy)
            else:
                logger.info(f"Buy signal for {symbol} at {price} (signal mode, no action taken)")
        
        elif signal < 0 and has_position:
            # Sell signal and active position
            position = self.active_positions[symbol]
            
            if position.side == OrderSide.BUY:
                if self.mode == 'auto':
                    self._close_position(symbol, price, timestamp, strategy)
                else:
                    logger.info(f"Sell signal for {symbol} at {price} (signal mode, no action taken)")
    
    def _open_position(self, symbol: str, side: str, price: float, timestamp: datetime, strategy: str):
        """
        Open new position
        
        Args:
            symbol: Trading symbol
            side: Position side (buy, sell)
            price: Current price
            timestamp: Signal timestamp
            strategy: Strategy name
        """
        try:
            # Get account balance
            balance = self.exchange.get_balance()
            
            if not balance:
                logger.error("Could not fetch balance")
                return
            
            # Determine currency for balance check
            quote_currency = symbol.split('/')[1]
            available_balance = balance.get('free', {}).get(quote_currency, 0.0)
            
            if available_balance <= 0:
                logger.error(f"Insufficient balance: {available_balance} {quote_currency}")
                return
            
            # Calculate position size based on risk management
            risk_params = config.TRADING_PARAMS['risk_management']
            max_position_size_percent = risk_params.get('max_position_size_percent', 5.0)
            
            # Calculate position size
            position_size_quote = available_balance * (max_position_size_percent / 100.0)
            position_size = position_size_quote / price
            
            # Round position size to appropriate precision
            position_size = self._round_amount(symbol, position_size)
            
            if position_size <= 0:
                logger.error(f"Invalid position size: {position_size}")
                return
            
            # Calculate stop loss and take profit
            stop_loss_percent = risk_params.get('default_stop_loss_percent', 2.0)
            take_profit_percent = risk_params.get('default_take_profit_percent', 5.0)
            
            stop_loss = price * (1 - stop_loss_percent / 100.0) if side == OrderSide.BUY else price * (1 + stop_loss_percent / 100.0)
            take_profit = price * (1 + take_profit_percent / 100.0) if side == OrderSide.BUY else price * (1 - take_profit_percent / 100.0)
            
            # Create market order
            order = Order(
                symbol=symbol,
                order_type=OrderType.MARKET,
                side=side,
                amount=position_size,
                price=None  # Market order doesn't need price
            )
            
            # Execute order
            order_result = self.exchange.create_order(order)
            
            if not order_result:
                logger.error("Failed to create order")
                return
            
            # Create position
            position = Position(
                symbol=symbol,
                side=side,
                amount=position_size,
                entry_price=price,
                entry_time=timestamp,
                stop_loss=stop_loss,
                take_profit=take_profit
            )
            
            position.entry_order_id = order.id
            
            # Add position to active positions
            self.active_positions[symbol] = position
            
            logger.info(f"Opened {side} position for {position_size} {symbol} at {price}")
            
        except Exception as e:
            logger.error(f"Error opening position: {e}")
    
    def _close_position(self, symbol: str, price: float, timestamp: datetime, strategy: str):
        """
        Close existing position
        
        Args:
            symbol: Trading symbol
            price: Current price
            timestamp: Signal timestamp
            strategy: Strategy name
        """
        try:
            # Check if position exists
            if symbol not in self.active_positions:
                logger.error(f"No active position for {symbol}")
                return
            
            position = self.active_positions[symbol]
            
            # Create market order (opposite side of position)
            side = OrderSide.SELL if position.side == OrderSide.BUY else OrderSide.BUY
            
            order = Order(
                symbol=symbol,
                order_type=OrderType.MARKET,
                side=side,
                amount=position.amount,
                price=None  # Market order doesn't need price
            )
            
            # Execute order
            order_result = self.exchange.create_order(order)
            
            if not order_result:
                logger.error("Failed to create order")
                return
            
            # Close position
            position.close(price, timestamp, order.id)
            
            # Move position to history
            self.position_history.append(position.to_dict())
            
            # Remove from active positions
            del self.active_positions[symbol]
            
            logger.info(f"Closed {position.side} position for {position.amount} {symbol} at {price}, PnL: {position.pnl:.2f} ({position.pnl_percent:.2f}%)")
            
        except Exception as e:
            logger.error(f"Error closing position: {e}")
    
    def _check_positions(self):
        """Check active positions for stop loss and take profit"""
        for symbol, position in list(self.active_positions.items()):
            try:
                # Get current price
                ticker = self.exchange.get_ticker(symbol)
                
                if not ticker:
                    continue
                
                current_price = ticker['last']
                
                # Check if position should be closed
                if position.should_close(current_price):
                    reason = "stop loss" if (
                        (position.side == OrderSide.BUY and current_price <= position.stop_loss) or
                        (position.side == OrderSide.SELL and current_price >= position.stop_loss)
                    ) else "take profit"
                    
                    logger.info(f"Closing position for {symbol} at {current_price} due to {reason}")
                    
                    self._close_position(
                        symbol=symbol,
                        price=current_price,
                        timestamp=datetime.now(),
                        strategy="stop_loss_take_profit"
                    )
            
            except Exception as e:
                logger.error(f"Error checking position for {symbol}: {e}")
    
    def _round_amount(self, symbol: str, amount: float) -> float:
        """
        Round amount to appropriate precision for symbol
        
        Args:
            symbol: Trading symbol
            amount: Amount to round
            
        Returns:
            Rounded amount
        """
        try:
            # Get market info
            market = self.exchange.exchange.market(symbol)
            
            # Get precision
            precision = market['precision']['amount']
            
            # Round amount
            return float(self.exchange.exchange.amount_to_precision(symbol, amount))
            
        except Exception as e:
            logger.error(f"Error rounding amount: {e}")
            return amount
    
    def add_signal(self, symbol: str, signal: int, price: float, strategy: str):
        """
        Add trading signal to queue
        
        Args:
            symbol: Trading symbol
            signal: Signal value (1 for buy, -1 for sell, 0 for neutral)
            price: Current price
            strategy: Strategy name
        """
        signal_data = {
            'symbol': symbol,
            'signal': signal,
            'price': price,
            'timestamp': datetime.now(),
            'strategy': strategy
        }
        
        self.signal_queue.put(signal_data)
        logger.info(f"Added signal to queue: {symbol} {signal} at {price}")
    
    def get_active_positions(self) -> List[Dict]:
        """
        Get active positions
        
        Returns:
            List of active positions
        """
        return [position.to_dict() for position in self.active_positions.values()]
    
    def get_position_history(self) -> List[Dict]:
        """
        Get position history
        
        Returns:
            List of closed positions
        """
        return self.position_history
    
    def get_order_history(self) -> List[Dict]:
        """
        Get order history
        
        Returns:
            List of orders
        """
        return self.order_history


class TradingBot:
    """Main class for the trading bot"""
    
    def __init__(self, exchange_id: str = None, mode: str = 'signal'):
        """
        Initialize trading bot
        
        Args:
            exchange_id: Exchange identifier (default from config)
            mode: Trading mode ('auto' or 'signal')
        """
        self.exchange_id = exchange_id or config.DEFAULT_EXCHANGE
        self.mode = mode
        self.data_manager = create_data_manager(self.exchange_id)
        self.strategy_manager = create_strategy_manager()
        self.trading_executor = TradingExecutor(self.exchange_id, self.mode)
        
        # Initialize state
        self.is_running = False
        self.monitored_symbols = config.TRADING_PARAMS['default_symbols']
        self.active_strategy = config.TRADING_PARAMS['default_strategies'][0]
        self.timeframe = config.TRADING_PARAMS['default_timeframes'][3]  # 1h
        
        logger.info(f"Initialized trading bot for {self.exchange_id} in {self.mode} mode")
    
    def start(self):
        """Start trading bot"""
        if self.is_running:
            logger.warning("Trading bot is already running")
            return
        
        # Start trading executor
        self.trading_executor.start()
        
        # Set running flag
        self.is_running = True
        
        # Start monitoring symbols
        for symbol in self.monitored_symbols:
            self._monitor_symbol(symbol)
        
        logger.info(f"Trading bot started in {self.mode} mode")
    
    def stop(self):
        """Stop trading bot"""
        if not self.is_running:
            logger.warning("Trading bot is not running")
            return
        
        # Stop trading executor
        self.trading_executor.stop()
        
        # Set running flag
        self.is_running = False
        
        logger.info("Trading bot stopped")
    
    def _monitor_symbol(self, symbol: str):
        """
        Start monitoring symbol for trading signals
        
        Args:
            symbol: Trading symbol
        """
        try:
            # Subscribe to real-time data
            self.trading_executor.market_streamer.subscribe_ticker(
                symbol,
                lambda data: self._process_ticker_update(symbol, data)
            )
            
            logger.info(f"Started monitoring {symbol}")
            
        except Exception as e:
            logger.error(f"Error monitoring {symbol}: {e}")
    
    def _process_ticker_update(self, symbol: str, ticker_data: Dict):
        """
        Process ticker update and generate trading signals
        
        Args:
            symbol: Trading symbol
            ticker_data: Ticker data
        """
        try:
            # Get latest data for analysis
            data = self.data_manager.get_historical_data(symbol, self.timeframe)
            
            if data.empty:
                return
            
            # Get strategy
            strategy = self.strategy_manager.get_strategy(self.active_strategy)
            
            if not strategy:
                logger.error(f"Strategy {self.active_strategy} not found")
                return
            
            # Generate signals
            signals_df = strategy.generate_signals(data)
            
            # Get latest signal
            latest_signal = signals_df['signal'].iloc[-1]
            
            # Add signal to trading executor
            if latest_signal != 0:
                self.trading_executor.add_signal(
                    symbol=symbol,
                    signal=latest_signal,
                    price=ticker_data['last_price'],
                    strategy=self.active_strategy
                )
            
        except Exception as e:
            logger.error(f"Error processing ticker update for {symbol}: {e}")
    
    def set_mode(self, mode: str):
        """
        Set trading mode
        
        Args:
            mode: Trading mode ('auto' or 'signal')
        """
        if mode not in ['auto', 'signal']:
            logger.error(f"Invalid mode: {mode}")
            return
        
        if self.mode == mode:
            return
        
        # Stop bot if running
        was_running = self.is_running
        if was_running:
            self.stop()
        
        # Set new mode
        self.mode = mode
        self.trading_executor.mode = mode
        
        # Restart bot if it was running
        if was_running:
            self.start()
        
        logger.info(f"Trading mode set to {mode}")
    
    def set_strategy(self, strategy_name: str):
        """
        Set active strategy
        
        Args:
            strategy_name: Strategy name
        """
        # Check if strategy exists
        if not self.strategy_manager.get_strategy(strategy_name):
            logger.error(f"Strategy {strategy_name} not found")
            return
        
        # Set active strategy
        self.active_strategy = strategy_name
        
        logger.info(f"Active strategy set to {strategy_name}")
    
    def set_timeframe(self, timeframe: str):
        """
        Set timeframe
        
        Args:
            timeframe: Timeframe
        """
        if timeframe not in config.TRADING_PARAMS['default_timeframes']:
            logger.error(f"Invalid timeframe: {timeframe}")
            return
        
        # Set timeframe
        self.timeframe = timeframe
        
        logger.info(f"Timeframe set to {timeframe}")
    
    def add_symbol(self, symbol: str):
        """
        Add symbol to monitored symbols
        
        Args:
            symbol: Trading symbol
        """
        if symbol in self.monitored_symbols:
            logger.warning(f"Symbol {symbol} is already monitored")
            return
        
        # Add symbol to monitored symbols
        self.monitored_symbols.append(symbol)
        
        # Start monitoring if bot is running
        if self.is_running:
            self._monitor_symbol(symbol)
        
        logger.info(f"Added {symbol} to monitored symbols")
    
    def remove_symbol(self, symbol: str):
        """
        Remove symbol from monitored symbols
        
        Args:
            symbol: Trading symbol
        """
        if symbol not in self.monitored_symbols:
            logger.warning(f"Symbol {symbol} is not monitored")
            return
        
        # Remove symbol from monitored symbols
        self.monitored_symbols.remove(symbol)
        
        logger.info(f"Removed {symbol} from monitored symbols")
    
    def get_active_positions(self) -> List[Dict]:
        """
        Get active positions
        
        Returns:
            List of active positions
        """
        return self.trading_executor.get_active_positions()
    
    def get_position_history(self) -> List[Dict]:
        """
        Get position history
        
        Returns:
            List of closed positions
        """
        return self.trading_executor.get_position_history()
    
    def get_order_history(self) -> List[Dict]:
        """
        Get order history
        
        Returns:
            List of orders
        """
        return self.trading_executor.get_order_history()


# Factory function to create trading bot
def create_trading_bot(exchange_id: str = None, mode: str = 'signal') -> TradingBot:
    """
    Create a trading bot
    
    Args:
        exchange_id: Exchange identifier (default from config)
        mode: Trading mode ('auto' or 'signal')
        
    Returns:
        TradingBot instance
    """
    return TradingBot(exchange_id, mode)


# Test function to verify the module works correctly
def test_trading_bot():
    """Test trading bot functionality"""
    # Configure logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # Create trading bot in signal mode
    bot = create_trading_bot(mode='signal')
    
    try:
        # Start bot
        bot.start()
        
        # Wait for some time to receive signals
        logger.info("Waiting for signals (30 seconds)...")
        time.sleep(30)
        
        # Get active positions
        positions = bot.get_active_positions()
        logger.info(f"Active positions: {len(positions)}")
        
        # Get position history
        history = bot.get_position_history()
        logger.info(f"Position history: {len(history)}")
        
    except KeyboardInterrupt:
        logger.info("Test interrupted by user")
    finally:
        # Stop bot
        bot.stop()
        logger.info("Test completed")


if __name__ == "__main__":
    # Run test
    test_trading_bot()
